{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Does Python need yet another retry / poll library? It needs at least one that isn't coupled to decorators and functions. Decorators prevent the caller from customizing delay options, and organizing the code around functions hinders any custom handling of failures.</p> <p>Waiter is built around iteration instead, because the foundation of retrying / polling is a slowly executing loop. The resulting interface is both easier to use and more flexible, decoupling the delay algorithms from the application logic.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#creation","title":"creation","text":"<p>Supply a number of seconds to repeat endlessly, or any iterable of seconds.</p> <pre><code>from waiter import wait\n\nwait(1)                 # 1, 1, 1, 1, ...\nwait([1] * 3)           # 1, 1, 1\nwait([0.5, 0.5, 60])    # circuit breaker\n</code></pre> <p>Iterable delays can express any waiting strategy, and constructors for common algorithms are also provided.</p> <pre><code>wait.count(1)           # incremental backoff 1, 2, 3, 4, 5, ...\nwait(1) + 1             # alternate syntax 1, 2, 3, 4, 5, ...\nwait.fibonacci(1)       # 1, 1, 2, 3, 5, ...\nwait.polynomial(2)      # 0, 1, 4, 9, 16, ...\n\nwait.exponential(2)     # exponential backoff 1, 2, 4, 8, ...\nbackoff = wait(1) * 2   # alternate syntax 1, 2, 4, 8, ...\nbackoff[:3]             # limit attempt count 1, 2, 4\nbackoff &lt;= 5            # set maximum delay   1, 2, 4, 5, 5, 5, ...\nbackoff.random(-1, 1)   # add random jitter\n</code></pre>"},{"location":"#iteration","title":"iteration","text":"<p>Then simply use the <code>wait</code> object like any iterable, yielding the amount of elapsed time. Timeouts also supported of course.</p> <pre><code>from waiter import wait, suppress, first\n\nfor elapsed in wait(delays):            # first iteration is immediate\n    with suppress(exception):           # then each subsequent iteration sleeps as necessary\n        ...\n        break\n\nfor _ in wait(delays, timeout):         # standard convention for ignoring a loop variable\n    ...                                 # won't sleep past the timeout\n    if ...:\n        break\n\nresults = (... for _ in wait(delays))   # expressions are even easier\nfirst(predicate, results[, default])    # filter for first true item\nassert any(results)                     # perfect for tests too\n</code></pre>"},{"location":"#functions","title":"functions","text":"<p>Yes, functional versions are provided, as well as being trivial to implement.</p> <pre><code>wait(...).throttle(iterable)                      # generate items from iterable\nwait(...).repeat(func, *args, **kwargs)           # generate successive results\nwait(...).retry(exception, func, *args, **kwargs) # return first success or re-raise exception\nwait(...).poll(predicate, func, *args, **kwargs)  # return first success or raise StopIteration\n</code></pre> <p>The decorator variants are partial applications of the corresponding methods.</p> <pre><code>backoff = wait(0.1) * 2\n@backoff.repeating\n@backoff.retrying(exception)\n@backoff.polling(predicate)\n</code></pre> <p>But in the real world: * the function may not exist or be succinctly written as a lambda * the predicate may not exist or be succinctly written as a lambda * logging may be required * there may be complex handling of different exceptions or results</p> <p>So consider the block form, just as decorators don't render <code>with</code> blocks superfluous. Also note <code>wait</code> objects are re-iterable provided their original delays were.</p>"},{"location":"#async","title":"async","text":"<p>Waiters also support async iteration. <code>throttle</code> optionally accepts an async iterable. <code>repeat</code>, <code>retry</code>, and <code>poll</code> optionally accept coroutine functions.</p>"},{"location":"#statistics","title":"statistics","text":"<p>Waiter objects have a <code>stats</code> attribute for aggregating statistics about the calls made. The base implementation is an attempt counter. The interface of the <code>stats</code> object itself is considered provisional, but can be extended by overriding the <code>Stats</code> class attribute. The <code>add</code> method also allows customization of the iterable values; elapsed time is the default.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install waiter\n</code></pre>"},{"location":"#tests","title":"Tests","text":"<p>100% branch coverage.</p> <pre><code>pytest [--cov]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>from waiter import wait\nimport httpx\n\nbackoff = wait(0.1) * 2\nurl = 'https://httpbin.org/status/200'\n\n\n@backoff.retrying(OSError)\ndef get_url(url):\n    return httpx.get(url)\n\n\nget_url(url)\n</pre> from waiter import wait import httpx  backoff = wait(0.1) * 2 url = 'https://httpbin.org/status/200'   @backoff.retrying(OSError) def get_url(url):     return httpx.get(url)   get_url(url) Out[1]: <pre>&lt;Response [200 OK]&gt;</pre> In\u00a0[2]: Copied! <pre>from functools import partial\n\nget_url = partial(backoff.retry, OSError, httpx.Client().get)\nget_url(url)\n</pre> from functools import partial  get_url = partial(backoff.retry, OSError, httpx.Client().get) get_url(url) Out[2]: <pre>&lt;Response [200 OK]&gt;</pre> <p>Which in turn raises the question of whether <code>get_url</code> is worth abstracting at all.  The completely in-lined variation is arguably just as readable.</p> In\u00a0[3]: Copied! <pre>backoff.retry(OSError, httpx.Client().get, url)\n</pre> backoff.retry(OSError, httpx.Client().get, url) Out[3]: <pre>&lt;Response [200 OK]&gt;</pre> In\u00a0[4]: Copied! <pre>backoff.poll(lambda r: not r.is_error, httpx.Client().get, url)\n</pre> backoff.poll(lambda r: not r.is_error, httpx.Client().get, url) Out[4]: <pre>&lt;Response [200 OK]&gt;</pre> In\u00a0[5]: Copied! <pre>import logging\n\n\ndef get_url(url):\n    \"\"\"Retry and log both connection and http errors.\"\"\"\n    with httpx.Client() as client:\n        for _ in backoff[:1]:\n            try:\n                resp = client.get(url)\n            except OSError:\n                logging.exception(url)\n                continue\n            if not resp.is_error:\n                return resp\n            logging.error(f'{url} {resp.status_code}')\n    return None\n\n\nget_url('https://httpbin.org/status/404')\n</pre> import logging   def get_url(url):     \"\"\"Retry and log both connection and http errors.\"\"\"     with httpx.Client() as client:         for _ in backoff[:1]:             try:                 resp = client.get(url)             except OSError:                 logging.exception(url)                 continue             if not resp.is_error:                 return resp             logging.error(f'{url} {resp.status_code}')     return None   get_url('https://httpbin.org/status/404') <pre>ERROR:root:https://httpbin.org/status/404 404\n</pre> <pre>ERROR:root:https://httpbin.org/status/404 404\n</pre> In\u00a0[6]: Copied! <pre>import httpx\n\n\nasync def get_url(url):\n    return await backoff.retry(OSError, httpx.AsyncClient().get, url)\n\n\nget_url(url)\n</pre> import httpx   async def get_url(url):     return await backoff.retry(OSError, httpx.AsyncClient().get, url)   get_url(url) Out[6]: <pre>&lt;coroutine object get_url at 0x7ff548e8ab50&gt;</pre> In\u00a0[7]: Copied! <pre>async def get_url(url):\n    async with httpx.AsyncClient() as client:\n        async for _ in backoff:\n            resp = await client.get(url)\n            if resp.status == 200:\n                return resp\n\n\nget_url(url)\n</pre> async def get_url(url):     async with httpx.AsyncClient() as client:         async for _ in backoff:             resp = await client.get(url)             if resp.status == 200:                 return resp   get_url(url) Out[7]: <pre>&lt;coroutine object get_url at 0x7ff55009da40&gt;</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":"<p>HTTP requests as an example of an unreliable operation.</p>"},{"location":"examples/#decorators","title":"decorators\u00b6","text":"<p>Using decorators to retry functions is a popular choice, and <code>waiter</code> supports this pattern.</p>"},{"location":"examples/#functions","title":"functions\u00b6","text":"<p>But there's a problem with this approach: the implementer of the unreliable function is choosing the retry strategy instead of the caller.  Which in practice means the decorated function is often just a wrapper around the underlying implementation.</p> <p>The above example could just as easily be a partially bound function, and that is in fact how the <code>waiter</code> decorators are implemented.  This approach also facilitates reusing clients, which should be done for repeated requests anyway.</p>"},{"location":"examples/#iteration","title":"iteration\u00b6","text":"<p>But even the functional approach breaks down if the unreliable code is more naturally expressed as a block, or there are multiple failure conditions, or logging is required, etc.  It's not worth creating what amounts to a domain-specific language just to avoid a for-loop.</p>"},{"location":"examples/#asyncio","title":"asyncio\u00b6","text":"<p><code>waiter</code> also supports async iteration and coroutine functions.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#waiter.waiter","title":"<code>waiter.waiter</code>","text":"<p>An iterable which sleeps for given delays. Aliased as <code>wait</code>.</p> <p>Parameters:</p> Name Type Description Default <code>delays iterable | number</code> <p>any iterable of seconds, or a scalar which is repeated endlessly</p> required <code>timeout number</code> <p>optional timeout for iteration</p> required Source code in <code>waiter/__init__.py</code> <pre><code>class waiter:\n    \"\"\"An iterable which sleeps for given delays. Aliased as `wait`.\n\n    Args:\n        delays iterable | number: any iterable of seconds, or a scalar which is repeated endlessly\n        timeout number: optional timeout for iteration\n    \"\"\"\n\n    Stats = Stats\n\n    def __init__(self, delays, timeout=float('inf')):\n        with suppress(TypeError) as excs:\n            iter(delays)\n        self.delays = itertools.repeat(delays) if excs else delays\n        self.timeout = timeout\n        self.stats = self.Stats()\n\n    def __iter__(self):\n        \"\"\"Generate a slow loop of elapsed time.\"\"\"\n        start = time.time()\n        yield self.stats.add(0, 0.0)\n        for attempt, delay in enumerate(self.delays, 1):\n            remaining = start + self.timeout - time.time()\n            if remaining &lt; 0:\n                break\n            time.sleep(min(delay, remaining))\n            yield self.stats.add(attempt, time.time() - start)\n\n    async def __aiter__(self):\n        \"\"\"Asynchronously generate a slow loop of elapsed time.\"\"\"\n        start = time.time()\n        yield self.stats.add(0, 0.0)\n        for attempt, delay in enumerate(self.delays, 1):\n            remaining = start + self.timeout - time.time()\n            if remaining &lt; 0:\n                break\n            await asyncio.sleep(min(delay, remaining))\n            yield self.stats.add(attempt, time.time() - start)\n\n    def clone(self, func: Callable, *args) -&gt; 'waiter':\n        return type(self)(reiter(func, *args), self.timeout)\n\n    def map(self, func: Callable, *iterables: Iterable) -&gt; 'waiter':\n        \"\"\"Return new waiter with function mapped across delays.\"\"\"\n        return self.clone(map, func, self.delays, *iterables)\n\n    @classmethod\n    def fibonacci(cls, delay, **kwargs) -&gt; 'waiter':\n        \"\"\"Create waiter with fibonacci backoff.\"\"\"\n        return cls(reiter(fibonacci, delay, delay), **kwargs)\n\n    @classmethod\n    def count(cls, *args, **kwargs) -&gt; 'waiter':\n        \"\"\"Create waiter based on `itertools.count`.\"\"\"\n        return cls(reiter(itertools.count, *args), **kwargs)\n\n    @classmethod\n    def accumulate(cls, *args, **kwargs) -&gt; 'waiter':\n        \"\"\"Create waiter based on `itertools.accumulate`.\"\"\"\n        return cls(reiter(itertools.accumulate, *args), **kwargs)\n\n    @classmethod\n    def exponential(cls, base, **kwargs) -&gt; 'waiter':\n        \"\"\"Create waiter with exponential backoff.\"\"\"\n        return cls.count(**kwargs).map(base.__pow__)\n\n    @classmethod\n    def polynomial(cls, exp, **kwargs) -&gt; 'waiter':\n        \"\"\"Create waiter with polynomial backoff.\"\"\"\n        return cls.count(**kwargs).map(exp.__rpow__)\n\n    def __getitem__(self, slc: slice) -&gt; 'waiter':\n        \"\"\"Slice delays, e.g., to limit attempt count.\"\"\"\n        return self.clone(itertools.islice, self.delays, slc.start, slc.stop, slc.step)\n\n    def __le__(self, ceiling) -&gt; 'waiter':\n        \"\"\"Limit maximum delay generated.\"\"\"\n        return self.map(partial(min, ceiling))\n\n    def __ge__(self, floor) -&gt; 'waiter':\n        \"\"\"Limit minimum delay generated.\"\"\"\n        return self.map(partial(max, floor))\n\n    def __add__(self, step) -&gt; 'waiter':\n        \"\"\"Generate incremental backoff.\"\"\"\n        return self.map(operator.add, reiter(itertools.count, 0, step))\n\n    def __mul__(self, factor) -&gt; 'waiter':\n        \"\"\"Generate exponential backoff.\"\"\"\n        return self.map(operator.mul, reiter(map, factor.__pow__, reiter(itertools.count)))\n\n    def random(self, start, stop) -&gt; 'waiter':\n        \"\"\"Add random jitter within given range.\"\"\"\n        return self.map(lambda delay: delay + random.uniform(start, stop))\n\n    @singledispatchmethod\n    def throttle(self, iterable: Iterable):\n        \"\"\"Delay iteration.\"\"\"\n        return map(operator.itemgetter(1), zip(self, iterable))\n\n    @throttle.register\n    async def _(self, iterable: AsyncIterable) -&gt; AsyncIterator:\n        anext = iterable.__aiter__().__anext__\n        with suppress(StopAsyncIteration):  # type: ignore\n            async for _ in self:\n                yield await anext()\n\n    def stream(self, queue: Iterable, size: int | None = None) -&gt; Iterator:\n        \"\"\"Generate chained values in groups from an iterable.\n\n        The queue can be extended while in use.\n        \"\"\"\n        it = iter(queue)\n        groups = iter(lambda: list(itertools.islice(it, size)), [])\n        if isinstance(queue, Sequence):\n            groups = grouped(queue, size)\n        return itertools.chain.from_iterable(self.throttle(groups))\n\n    def suppressed(self, exception, func: Callable, iterable: Iterable) -&gt; Iterator[tuple]:\n        \"\"\"Generate `arg, func(arg)` pairs while exception isn't raised.\"\"\"\n        queue = list(iterable)\n        for arg in self.stream(queue):\n            try:\n                yield arg, func(arg)\n            except exception:\n                queue.append(arg)\n\n    def filtered(self, predicate: Callable, func: Callable, iterable: Iterable) -&gt; Iterator[tuple]:\n        \"\"\"Generate `arg, func(arg)` pairs while predicate evaluates to true.\"\"\"\n        queue = list(iterable)\n        for arg in self.stream(queue):\n            result = func(arg)\n            if predicate(result):\n                yield arg, result\n            else:\n                queue.append(arg)\n\n    def repeat(self, func: Callable, *args, **kwargs):\n        \"\"\"Repeat function call.\"\"\"\n        if inspect.iscoroutinefunction(func):\n            return self.arepeat(func, *args, **kwargs)\n        return (func(*args, **kwargs) for _ in self)\n\n    async def arepeat(self, func: Callable, *args, **kwargs) -&gt; AsyncIterator:\n        async for _ in self:\n            yield await func(*args, **kwargs)\n\n    def retry(self, exception: Exception, func: Callable, *args, **kwargs):\n        \"\"\"Repeat function call until exception isn't raised.\"\"\"\n        if inspect.iscoroutinefunction(func):\n            return self.aretry(exception, func, *args, **kwargs)\n        for _ in self:\n            with suppress(exception) as excs:\n                return func(*args, **kwargs)\n        raise excs[0]\n\n    async def aretry(self, exception: Exception, func: Callable, *args, **kwargs):\n        async for _ in self:\n            with suppress(exception) as excs:\n                return await func(*args, **kwargs)\n        raise excs[0]\n\n    def poll(self, predicate: Callable, func: Callable, *args, **kwargs):\n        \"\"\"Repeat function call until predicate evaluates to true.\"\"\"\n        if inspect.iscoroutinefunction(func):\n            return self.apoll(predicate, func, *args, **kwargs)\n        return first(predicate, self.repeat(func, *args, **kwargs))\n\n    async def apoll(self, predicate: Callable, func: Callable, *args, **kwargs):\n        async for result in self.repeat(func, *args, **kwargs):\n            if predicate(result):  # pragma: no branch\n                return result\n        raise StopAsyncIteration\n\n    def repeating(self, func: Callable):\n        \"\"\"A decorator for `repeat`.\"\"\"\n        return partialmethod(self.repeat, func)\n\n    def retrying(self, exception: Exception):\n        \"\"\"Return a decorator for `retry`.\"\"\"\n        return partial(partialmethod, self.retry, exception)\n\n    def polling(self, predicate: Callable):\n        \"\"\"Return a decorator for `poll`.\"\"\"\n        return partial(partialmethod, self.poll, predicate)\n</code></pre>"},{"location":"reference/#waiter.waiter.__add__","title":"<code>__add__(step)</code>","text":"<p>Generate incremental backoff.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __add__(self, step) -&gt; 'waiter':\n    \"\"\"Generate incremental backoff.\"\"\"\n    return self.map(operator.add, reiter(itertools.count, 0, step))\n</code></pre>"},{"location":"reference/#waiter.waiter.__aiter__","title":"<code>__aiter__()</code>  <code>async</code>","text":"<p>Asynchronously generate a slow loop of elapsed time.</p> Source code in <code>waiter/__init__.py</code> <pre><code>async def __aiter__(self):\n    \"\"\"Asynchronously generate a slow loop of elapsed time.\"\"\"\n    start = time.time()\n    yield self.stats.add(0, 0.0)\n    for attempt, delay in enumerate(self.delays, 1):\n        remaining = start + self.timeout - time.time()\n        if remaining &lt; 0:\n            break\n        await asyncio.sleep(min(delay, remaining))\n        yield self.stats.add(attempt, time.time() - start)\n</code></pre>"},{"location":"reference/#waiter.waiter.__ge__","title":"<code>__ge__(floor)</code>","text":"<p>Limit minimum delay generated.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __ge__(self, floor) -&gt; 'waiter':\n    \"\"\"Limit minimum delay generated.\"\"\"\n    return self.map(partial(max, floor))\n</code></pre>"},{"location":"reference/#waiter.waiter.__getitem__","title":"<code>__getitem__(slc)</code>","text":"<p>Slice delays, e.g., to limit attempt count.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __getitem__(self, slc: slice) -&gt; 'waiter':\n    \"\"\"Slice delays, e.g., to limit attempt count.\"\"\"\n    return self.clone(itertools.islice, self.delays, slc.start, slc.stop, slc.step)\n</code></pre>"},{"location":"reference/#waiter.waiter.__iter__","title":"<code>__iter__()</code>","text":"<p>Generate a slow loop of elapsed time.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __iter__(self):\n    \"\"\"Generate a slow loop of elapsed time.\"\"\"\n    start = time.time()\n    yield self.stats.add(0, 0.0)\n    for attempt, delay in enumerate(self.delays, 1):\n        remaining = start + self.timeout - time.time()\n        if remaining &lt; 0:\n            break\n        time.sleep(min(delay, remaining))\n        yield self.stats.add(attempt, time.time() - start)\n</code></pre>"},{"location":"reference/#waiter.waiter.__le__","title":"<code>__le__(ceiling)</code>","text":"<p>Limit maximum delay generated.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __le__(self, ceiling) -&gt; 'waiter':\n    \"\"\"Limit maximum delay generated.\"\"\"\n    return self.map(partial(min, ceiling))\n</code></pre>"},{"location":"reference/#waiter.waiter.__mul__","title":"<code>__mul__(factor)</code>","text":"<p>Generate exponential backoff.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def __mul__(self, factor) -&gt; 'waiter':\n    \"\"\"Generate exponential backoff.\"\"\"\n    return self.map(operator.mul, reiter(map, factor.__pow__, reiter(itertools.count)))\n</code></pre>"},{"location":"reference/#waiter.waiter.accumulate","title":"<code>accumulate(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create waiter based on <code>itertools.accumulate</code>.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@classmethod\ndef accumulate(cls, *args, **kwargs) -&gt; 'waiter':\n    \"\"\"Create waiter based on `itertools.accumulate`.\"\"\"\n    return cls(reiter(itertools.accumulate, *args), **kwargs)\n</code></pre>"},{"location":"reference/#waiter.waiter.count","title":"<code>count(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create waiter based on <code>itertools.count</code>.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@classmethod\ndef count(cls, *args, **kwargs) -&gt; 'waiter':\n    \"\"\"Create waiter based on `itertools.count`.\"\"\"\n    return cls(reiter(itertools.count, *args), **kwargs)\n</code></pre>"},{"location":"reference/#waiter.waiter.exponential","title":"<code>exponential(base, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create waiter with exponential backoff.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@classmethod\ndef exponential(cls, base, **kwargs) -&gt; 'waiter':\n    \"\"\"Create waiter with exponential backoff.\"\"\"\n    return cls.count(**kwargs).map(base.__pow__)\n</code></pre>"},{"location":"reference/#waiter.waiter.fibonacci","title":"<code>fibonacci(delay, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create waiter with fibonacci backoff.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@classmethod\ndef fibonacci(cls, delay, **kwargs) -&gt; 'waiter':\n    \"\"\"Create waiter with fibonacci backoff.\"\"\"\n    return cls(reiter(fibonacci, delay, delay), **kwargs)\n</code></pre>"},{"location":"reference/#waiter.waiter.filtered","title":"<code>filtered(predicate, func, iterable)</code>","text":"<p>Generate <code>arg, func(arg)</code> pairs while predicate evaluates to true.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def filtered(self, predicate: Callable, func: Callable, iterable: Iterable) -&gt; Iterator[tuple]:\n    \"\"\"Generate `arg, func(arg)` pairs while predicate evaluates to true.\"\"\"\n    queue = list(iterable)\n    for arg in self.stream(queue):\n        result = func(arg)\n        if predicate(result):\n            yield arg, result\n        else:\n            queue.append(arg)\n</code></pre>"},{"location":"reference/#waiter.waiter.map","title":"<code>map(func, *iterables)</code>","text":"<p>Return new waiter with function mapped across delays.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def map(self, func: Callable, *iterables: Iterable) -&gt; 'waiter':\n    \"\"\"Return new waiter with function mapped across delays.\"\"\"\n    return self.clone(map, func, self.delays, *iterables)\n</code></pre>"},{"location":"reference/#waiter.waiter.poll","title":"<code>poll(predicate, func, *args, **kwargs)</code>","text":"<p>Repeat function call until predicate evaluates to true.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def poll(self, predicate: Callable, func: Callable, *args, **kwargs):\n    \"\"\"Repeat function call until predicate evaluates to true.\"\"\"\n    if inspect.iscoroutinefunction(func):\n        return self.apoll(predicate, func, *args, **kwargs)\n    return first(predicate, self.repeat(func, *args, **kwargs))\n</code></pre>"},{"location":"reference/#waiter.waiter.polling","title":"<code>polling(predicate)</code>","text":"<p>Return a decorator for <code>poll</code>.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def polling(self, predicate: Callable):\n    \"\"\"Return a decorator for `poll`.\"\"\"\n    return partial(partialmethod, self.poll, predicate)\n</code></pre>"},{"location":"reference/#waiter.waiter.polynomial","title":"<code>polynomial(exp, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create waiter with polynomial backoff.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@classmethod\ndef polynomial(cls, exp, **kwargs) -&gt; 'waiter':\n    \"\"\"Create waiter with polynomial backoff.\"\"\"\n    return cls.count(**kwargs).map(exp.__rpow__)\n</code></pre>"},{"location":"reference/#waiter.waiter.random","title":"<code>random(start, stop)</code>","text":"<p>Add random jitter within given range.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def random(self, start, stop) -&gt; 'waiter':\n    \"\"\"Add random jitter within given range.\"\"\"\n    return self.map(lambda delay: delay + random.uniform(start, stop))\n</code></pre>"},{"location":"reference/#waiter.waiter.repeat","title":"<code>repeat(func, *args, **kwargs)</code>","text":"<p>Repeat function call.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def repeat(self, func: Callable, *args, **kwargs):\n    \"\"\"Repeat function call.\"\"\"\n    if inspect.iscoroutinefunction(func):\n        return self.arepeat(func, *args, **kwargs)\n    return (func(*args, **kwargs) for _ in self)\n</code></pre>"},{"location":"reference/#waiter.waiter.repeating","title":"<code>repeating(func)</code>","text":"<p>A decorator for <code>repeat</code>.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def repeating(self, func: Callable):\n    \"\"\"A decorator for `repeat`.\"\"\"\n    return partialmethod(self.repeat, func)\n</code></pre>"},{"location":"reference/#waiter.waiter.retry","title":"<code>retry(exception, func, *args, **kwargs)</code>","text":"<p>Repeat function call until exception isn't raised.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def retry(self, exception: Exception, func: Callable, *args, **kwargs):\n    \"\"\"Repeat function call until exception isn't raised.\"\"\"\n    if inspect.iscoroutinefunction(func):\n        return self.aretry(exception, func, *args, **kwargs)\n    for _ in self:\n        with suppress(exception) as excs:\n            return func(*args, **kwargs)\n    raise excs[0]\n</code></pre>"},{"location":"reference/#waiter.waiter.retrying","title":"<code>retrying(exception)</code>","text":"<p>Return a decorator for <code>retry</code>.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def retrying(self, exception: Exception):\n    \"\"\"Return a decorator for `retry`.\"\"\"\n    return partial(partialmethod, self.retry, exception)\n</code></pre>"},{"location":"reference/#waiter.waiter.stream","title":"<code>stream(queue, size=None)</code>","text":"<p>Generate chained values in groups from an iterable.</p> <p>The queue can be extended while in use.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def stream(self, queue: Iterable, size: int | None = None) -&gt; Iterator:\n    \"\"\"Generate chained values in groups from an iterable.\n\n    The queue can be extended while in use.\n    \"\"\"\n    it = iter(queue)\n    groups = iter(lambda: list(itertools.islice(it, size)), [])\n    if isinstance(queue, Sequence):\n        groups = grouped(queue, size)\n    return itertools.chain.from_iterable(self.throttle(groups))\n</code></pre>"},{"location":"reference/#waiter.waiter.suppressed","title":"<code>suppressed(exception, func, iterable)</code>","text":"<p>Generate <code>arg, func(arg)</code> pairs while exception isn't raised.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def suppressed(self, exception, func: Callable, iterable: Iterable) -&gt; Iterator[tuple]:\n    \"\"\"Generate `arg, func(arg)` pairs while exception isn't raised.\"\"\"\n    queue = list(iterable)\n    for arg in self.stream(queue):\n        try:\n            yield arg, func(arg)\n        except exception:\n            queue.append(arg)\n</code></pre>"},{"location":"reference/#waiter.waiter.throttle","title":"<code>throttle(iterable)</code>","text":"<p>Delay iteration.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@singledispatchmethod\ndef throttle(self, iterable: Iterable):\n    \"\"\"Delay iteration.\"\"\"\n    return map(operator.itemgetter(1), zip(self, iterable))\n</code></pre>"},{"location":"reference/#waiter.suppress","title":"<code>waiter.suppress(*exceptions)</code>","text":"<p>Variant of <code>contextlib.suppress</code>, which also records exception.</p> Source code in <code>waiter/__init__.py</code> <pre><code>@contextlib.contextmanager\ndef suppress(*exceptions: Exception):\n    \"\"\"Variant of `contextlib.suppress`, which also records exception.\"\"\"\n    excs: list = []\n    try:\n        yield excs\n    except exceptions as exc:  # type: ignore\n        excs.append(exc)\n</code></pre>"},{"location":"reference/#waiter.first","title":"<code>waiter.first(predicate, iterable, *default)</code>","text":"<p>Return first item which evaluates to true, like <code>any</code> with filtering.</p> Source code in <code>waiter/__init__.py</code> <pre><code>def first(predicate: Callable, iterable: Iterable, *default):\n    \"\"\"Return first item which evaluates to true, like `any` with filtering.\"\"\"\n    return next(filter(predicate, iterable), *default)\n</code></pre>"}]}